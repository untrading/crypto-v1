{
  "language": "Solidity",
  "sources": {
    "@drad/eip-5173-diamond/contracts/nFR/InFR.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/interfaces/IERC165.sol\";\n\n/*\n *\n * @dev Interface for the Future Rewards Token Standard.\n *\n * A standardized way to receive future rewards for non-fungible tokens (NFTs.)\n *\n */\ninterface InFR is IERC165 {\n\n    event FRClaimed(address indexed account, uint256 indexed amount);\n\n    event FRDistributed(uint256 indexed tokenId, uint256 indexed soldPrice, uint256 indexed allocatedFR);\n\n    event Listed(uint256 indexed tokenId, uint256 indexed salePrice);\n\n    event Unlisted(uint256 indexed tokenId);\n\n    event Bought(uint256 indexed tokenId, uint256 indexed salePrice);\n\n    function list(uint256 tokenId, uint256 salePrice) external;\n\n    function unlist(uint256 tokenId) external;\n\n    function buy(uint256 tokenId) payable external;\n\n    function releaseFR(address payable account) external;\n\n    function getFRInfo(uint256 tokenId) external returns(uint8, uint256, uint256, uint256, uint256, address[] memory);\n\n    function getAllottedFR(address account) external returns(uint256);\n\n    function getListInfo(uint256 tokenId) external returns(uint256, address, bool);\n    \n}"
    },
    "@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address owner) {\n        owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        _setOwner(account);\n    }\n\n    function _setOwner(address account) internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, account);\n        l.owner = account;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return contract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondReadable {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IProxy {\n    error Proxy__ImplementationIsNotContract();\n\n    fallback() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\nimport { IProxy } from './IProxy.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy is IProxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        if (!implementation.isContract())\n            revert Proxy__ImplementationIsNotContract();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/core/IunCryptoManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.8;\n\ninterface IunCryptoManager {\n\n    event unCryptoProxyDeployed(address deployment);\n\n    function UNCRYPTO_DIAMOND() external view returns (address);\n\n    function getProxy(address underlyingToken) external view returns (address proxy);\n\n    function getProxyList() external view returns (address[] memory proxyList);\n\n    function deployCryptoProxy(address underlyingToken, address untradingManager, uint256 managerCut, string memory name, string memory symbol, string memory baseURI) external returns (address deployment);\n\n}"
    },
    "contracts/core/unCryptoManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '@solidstate/contracts/access/ownable/OwnableInternal.sol';\nimport { IunCryptoManager } from \"./IunCryptoManager.sol\";\nimport { unCryptoProxy } from \"../proxy/unCryptoProxy.sol\";\n\nimport { unCryptoManagerStorage } from \"./unCryptoManagerStorage.sol\";\n\ncontract unCryptoManager is IunCryptoManager, OwnableInternal {\n    using unCryptoManagerStorage for unCryptoManagerStorage.Layout;\n\n    address public immutable UNCRYPTO_DIAMOND;\n\n    constructor(address unDiamond) { //? Could put the untradingManager and managerCut in the constructor\n        UNCRYPTO_DIAMOND = unDiamond;\n    }\n\n    function getProxy(address underlyingToken) external view returns (address proxy) {\n        proxy = unCryptoManagerStorage.layout().getProxy(underlyingToken);\n    }\n\n    function getProxyList() external view returns (address[] memory proxyList) {\n        proxyList = unCryptoManagerStorage.layout().proxyList;\n    }   \n\n    function deployCryptoProxy(\n        address underlyingToken,\n        address untradingManager, \n        uint256 managerCut,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) external onlyOwner returns (address deployment) {\n        unCryptoManagerStorage.Layout storage m = unCryptoManagerStorage.layout();\n\n        deployment = address(\n            new unCryptoProxy(\n                UNCRYPTO_DIAMOND,\n                underlyingToken,\n                untradingManager,\n                managerCut,\n                name,\n                symbol,\n                baseURI\n            )\n        );\n\n        m.setProxy(underlyingToken, deployment);\n        m.proxyList.push(deployment);\n\n        emit unCryptoProxyDeployed(deployment);\n    }\n}"
    },
    "contracts/core/unCryptoManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.8;\n\nlibrary unCryptoManagerStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"untrading.Core.unCryptoManager.facet.storage\");\n\n    struct Layout {\n        mapping(address => address) proxyAddresses; // Mapping that represents a given token's proxy/derivative contract\n        address[] proxyList; // List of all created proxies\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function getProxy(Layout storage l, address underlyingToken) internal view returns (address) {\n        return l.proxyAddresses[underlyingToken];\n    }\n\n    function setProxy(Layout storage l, address underlying, address proxy) internal {\n        l.proxyAddresses[underlying] = proxy;\n    }\n}\n"
    },
    "contracts/management/ManagementStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.8;\n\nlibrary ManagementStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"untrading.unCryptoDiamond.facet.management.storage\");\n\n    struct Layout {\n        address untradingManager;\n        uint256 managerCut; // This is the cut of the oTokens that the untradingManager gets\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/proxy/unCryptoProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { IERC165 } from \"@solidstate/contracts/interfaces/IERC165.sol\";\nimport { ERC165BaseStorage } from \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\";\nimport { IERC721 } from \"@solidstate/contracts/interfaces/IERC721.sol\";\nimport { IERC20Metadata } from \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\";\nimport \"@drad/eip-5173-diamond/contracts/nFR/InFR.sol\";\n\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\nimport { OwnableStorage } from '@solidstate/contracts/access/ownable/OwnableStorage.sol';\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\n\nimport { WrappingStorage } from \"../wrapping/WrappingStorage.sol\";\nimport { UnwrappingStorage } from \"../unwrapping/UnwrappingStorage.sol\";\nimport \"../management/ManagementStorage.sol\";\n\ncontract unCryptoProxy is Proxy {\n    address private immutable UNCRYPTO_DIAMOND;\n\n    using ERC165BaseStorage for ERC165BaseStorage.Layout;\n\n    constructor(\n        address unCryptoDiamond,\n        address underlyingToken,\n        address untradingManager,\n        uint256 managerCut,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) {\n        require(managerCut <= 1e18, \"managerCut exceeds 100%\");\n\n        // Init Diamond Proxy\n        UNCRYPTO_DIAMOND = unCryptoDiamond;\n\n        // Init Ownable\n        OwnableStorage.layout().owner = msg.sender; // If we want to incorporate ownability into each individual proxy, probably unnecessary since we have the untradingManager\n\n        // Init the ERC721 Metadata for the unCrypto Proxy\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n        l.name = name;\n        l.symbol = symbol;\n        l.baseURI = baseURI;\n\n        // Declare all interfaces supported by the Diamond\n        ERC165BaseStorage.layout().supportedInterfaces[type(IERC165).interfaceId] = true;\n        ERC165BaseStorage.layout().supportedInterfaces[type(IERC721).interfaceId] = true;\n        ERC165BaseStorage.layout().supportedInterfaces[type(InFR).interfaceId] = true;\n\n        // Init the WrappingStorage and set underlying token\n        WrappingStorage.Layout storage w = WrappingStorage.layout();\n        w.underlyingTokenAddress = underlyingToken;\n        w.underlyingTokenDecimals = IERC20Metadata(underlyingToken).decimals();\n\n        assert(w.underlyingTokenDecimals > 0 && w.underlyingTokenDecimals <= 18);\n\n        // Init EIP-712\n        UnwrappingStorage.Layout storage u = UnwrappingStorage.layout();\n        u.DOMAIN_SEPARATOR = keccak256(abi.encode(UnwrappingStorage.EIP712DOMAINTYPE_HASH, keccak256(bytes(name)), UnwrappingStorage.VERSION_HASH, block.chainid, address(this), UnwrappingStorage.SALT));\n\n        // Init the manager and managerCut used by oTokens\n        ManagementStorage.Layout storage m = ManagementStorage.layout();\n        m.untradingManager = untradingManager;\n        m.managerCut = managerCut;\n    }\n\n    function _getImplementation() internal view override returns (address) {\n        return IDiamondReadable(UNCRYPTO_DIAMOND).facetAddress(msg.sig);\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/unwrapping/UnwrappingStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.8;\n\nlibrary UnwrappingStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"untrading.unCryptoDiamond.facet.ERC20.unwrapping.storage\");\n\n    bytes32 constant EIP712DOMAINTYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\");\n\n    bytes32 constant VERSION_HASH = keccak256(\"1\");\n\n    bytes32 constant TXTYPE_HASH = keccak256(\"Unwrap(address to,uint256 tokenId)\");\n\n    // keccak256(\"untradingcrypto\")\n    bytes32 constant SALT = 0xc25ebea6dd97ec30f15ce845010d7e9fee0398194f29ee544b5062c074544590;\n\n    struct Layout {\n        bytes32 DOMAIN_SEPARATOR;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/wrapping/WrappingStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.8;\n\nlibrary WrappingStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"untrading.unCryptoDiamond.facet.ERC20.wrapping.storage\");\n\n    struct Layout {\n        // Every token in this contract is assumed to be wrapped, so there is no need for another underlyingAmount variable or an isWrapped bool.\n        address underlyingTokenAddress;\n        uint8 underlyingTokenDecimals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}